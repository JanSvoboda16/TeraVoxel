#pragma once
#include "MeshNode.h"
#include "Transformations.h"

/**
* Generates different mesh shapes. 
* The returned meshNode does not contain
* any transformation in the top layer, so it can be transformed as needed.
*/
class MeshGenerator
{
private:

	static float hueToRGB(float p, float q, float t)
	{
		// computation generated by GPT 3.0
		if (t < 0.0f) t += 1.0f;
		if (t > 1.0f) t -= 1.0f;
		if (t < 1.0f / 6.0f) return p + (q - p) * 6.0f * t;
		if (t < 1.0f / 2.0f) return q;
		if (t < 2.0f / 3.0f) return p + (q - p) * (2.0f / 3.0f - t) * 6.0f;
		return p;
	}

public:

	static Vector4b SphereRainbowColor(float theta, float phi, uint8_t alpha)
	{
		// Color computation generated by GPT 3.0
		float hue = phi / (2.0f * 3.1419); 
		float saturation = 1.0f;
		float lightness = 0.5f;

		hue += theta / 3.1419;
		hue = fmod(hue, 1.0f); 

		float r, g, b;
		float q = lightness < 0.5f ? lightness * (1.0f + saturation) : lightness + saturation - lightness * saturation;
		float p = 2.0f * lightness - q;
		r = hueToRGB(p, q, hue + 1.0f / 3.0f);
		g = hueToRGB(p, q, hue);
		b = hueToRGB(p, q, hue - 1.0f / 3.0f);

		int red = static_cast<int>(r * 255.0f);
		int green = static_cast<int>(g * 255.0f);
		int blue = static_cast<int>(b * 255.0f);

		return { static_cast<uint8_t>(red), static_cast<uint8_t>(green), static_cast<uint8_t>(blue), alpha }; 
	}

	static std::shared_ptr<MeshNode> AxisCross(float axisLength, const Vector4b& color)
	{
		auto crossNode = std::make_shared<MeshNode>();

		Mesh axisMesh;
		axisMesh.SetOutlining(true);
		axisMesh.Data().push_back({ Vector3f(-axisLength,0,0), color });
		axisMesh.Data().push_back({ Vector3f(axisLength,0,0), color });
		axisMesh.Data().push_back({ Vector3f(axisLength,0,0), color });

		auto axisNodeX = std::make_shared<MeshNode>();
		axisNodeX->meshes.push_back(axisMesh);
		auto axisNodeY = std::make_shared<MeshNode>();
		axisNodeY->meshes.push_back(axisMesh);
		axisNodeY->transformation = Transformations::GetRotationMatrix('z', EIGEN_PI / 2.f);
		auto axisNodeZ = std::make_shared<MeshNode>();
		axisNodeZ->meshes.push_back(axisMesh);
		axisNodeZ->transformation = Transformations::GetRotationMatrix('y', EIGEN_PI / 2.f);

		crossNode->subNodes.push_back(axisNodeX);
		crossNode->subNodes.push_back(axisNodeY);
		crossNode->subNodes.push_back(axisNodeZ);

		return crossNode;
	}

	static std::shared_ptr<MeshNode> Sphere(float radius, int numSegments, const std::function<Vector4b(float, float)>& colorProvider)
	{
		auto meshNode = std::make_shared<MeshNode>();
		Mesh sphereMesh;

		auto& meshData = sphereMesh.Data();
		for (int i = 0; i < numSegments; ++i)
		{
			for (int j = 0; j < numSegments; ++j)
			{
				float theta1 = static_cast<float>(i) / static_cast<float>(numSegments) * EIGEN_PI;
				float theta2 = static_cast<float>(i + 1) / static_cast<float>(numSegments) * EIGEN_PI;
				float phi1 = static_cast<float>(j) / static_cast<float>(numSegments) * 2.0f * EIGEN_PI;
				float phi2 = static_cast<float>(j + 1) / static_cast<float>(numSegments) * 2.0f * EIGEN_PI;

				float x1 = radius * sin(theta1) * cos(phi1); 
				float y1 = radius * sin(theta1) * sin(phi1);
				float z1 = radius * cos(theta1);

				float x2 = radius * sin(theta2) * cos(phi1);
				float y2 = radius * sin(theta2) * sin(phi1);
				float z2 = radius * cos(theta2);

				float x3 = radius * sin(theta1) * cos(phi2);
				float y3 = radius * sin(theta1) * sin(phi2);
				float z3 = radius * cos(theta1);

				float x4 = radius * sin(theta2) * cos(phi2);
				float y4 = radius * sin(theta2) * sin(phi2);
				float z4 = radius * cos(theta2);

				Vector4b color1 = colorProvider(theta1, phi1);
				Vector4b color2 = colorProvider(theta2, phi1);
				Vector4b color3 = colorProvider(theta1, phi2);
				Vector4b color4 = colorProvider(theta2, phi2);


				meshData.push_back({ Vector3f(x1, y1, z1), color1 });
				meshData.push_back({ Vector3f(x2, y2, z2), color2 });
				meshData.push_back({ Vector3f(x3, y3, z3), color3 });

				meshData.push_back({ Vector3f(x2, y2, z2), color2 });
				meshData.push_back({ Vector3f(x4, y4, z4), color4 });
				meshData.push_back({ Vector3f(x3, y3, z3), color3 });
			}
		}
		meshNode->meshes.push_back(sphereMesh);

		return meshNode;
	}

	static std::shared_ptr<MeshNode> Cube(float width, float height, float depth, const std::function<Vector4b(bool, bool, bool)>& colorProvider)
	{	
		auto cubeNode = std::make_shared<MeshNode>();

		Mesh part1;
		part1.SetMode(MeshMode::Strip);
		auto& meshDataPart1 = part1.Data();

		meshDataPart1.push_back({ Vector3f(0,0,0), colorProvider(0,0,0) });
		meshDataPart1.push_back({ Vector3f(1,0,0), colorProvider(1,0,0) });
		meshDataPart1.push_back({ Vector3f(0,1,0), colorProvider(0,1,0) });
		meshDataPart1.push_back({ Vector3f(1,1,0), colorProvider(1,1,0) });

		meshDataPart1.push_back({ Vector3f(0,1,1), colorProvider(0,1,1) });
		meshDataPart1.push_back({ Vector3f(1,1,1), colorProvider(1,1,1) });
		
		meshDataPart1.push_back({ Vector3f(0,0,1), colorProvider(0,0,1) });
		meshDataPart1.push_back({ Vector3f(1,0,1), colorProvider(1,0,1) });

		cubeNode->meshes.push_back(part1);

		Mesh part2;
		part2.SetMode(MeshMode::Strip);
		auto& meshDataPart2 = part2.Data();
		
		meshDataPart2.push_back({ Vector3f(0,1,0), colorProvider(0,1,0) });
		meshDataPart2.push_back({ Vector3f(0,1,1), colorProvider(0,1,1) });
		meshDataPart2.push_back({ Vector3f(0,0,0), colorProvider(0,0,0) });
		meshDataPart2.push_back({ Vector3f(0,0,1), colorProvider(0,0,1) });

		meshDataPart2.push_back({ Vector3f(1,0,0), colorProvider(1,0,0) });
		meshDataPart2.push_back({ Vector3f(1,0,1), colorProvider(1,0,1) });

		meshDataPart2.push_back({ Vector3f(1,1,0), colorProvider(1,1,0) });
		meshDataPart2.push_back({ Vector3f(1,1,1), colorProvider(1,1,1) });

		cubeNode->meshes.push_back(part2);
		
		cubeNode->transformation = Transformations::GetShrinkMatrix(width, height, depth);

		auto meshNode = std::make_shared<MeshNode>();
		meshNode->subNodes.push_back(cubeNode);

		return meshNode;
	}
};

